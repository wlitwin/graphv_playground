<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
          "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Graphv Playground</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.13/ace.min.js" integrity="sha512-jB1NOQkR0yLnWmEZQTUW4REqirbskxoYNltZE+8KzXqs9gHG5mrxLR5w3TwUn6AylXkhZZWTPP894xcX/X8Kbg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.13/mode-ocaml.min.js" integrity="sha512-eNLvVhsqupKHLPWDlslUqBr0HTbb8KFm/azDm7ukE2PGSlmfPUsNuOTh8z+u8QjrsDpIQog09ntWF1Mo1a4aHA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.13/theme-ambiance.min.js" integrity="sha512-JSlcMPGsnCu53ixgQjR6qgTQNy/IzjibQob3GSP2JfZtd3naC3H6+NrOs1nDG8rsLulHYCIfBaXaU07G1PbR1g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.1.1/js/bootstrap.min.js" integrity="sha512-ewfXo9Gq53e1q1+WDTjaHAGZ8UvCWq0eXONhwDuIoaH8xz2r96uoAYaQCm1oQhnBfRXrvJztNXFsTloJfgbL5Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.1.1/css/bootstrap.min.css" integrity="sha512-6KY5s6UI5J7SVYuZB4S/CZMyPylqyyNZco376NM2Z8Sb8OxEdp02e1jkKk/wZxIEmjQ6DRCEBhni+gpr9c4tvA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.13/keybinding-vim.min.js" integrity="sha512-xp5tDiJMTiTOG6fjhMjNGaV3zw+kyaHq53hWvc5XrMvj/Pe/EOaby08LVHJp50xCE4VFF9rnJpRP4+JJyelGvQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.13/keybinding-emacs.min.js" integrity="sha512-1Z4E+xA+twF7jPCjJSFpeywof+mG40O66/pLMnAElym2Bu34nUTtTRQZG/eDkGIrp+bORyr2Ej2BWd6/sJBMWA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<style>

#top-div {
    display: flex;
    flex-direction: row;
    height: 100%;
}

#editor-wrapper {
    width: 100%;
    height: 100%;
    background-color: #3d3d3d;
}

#editor {
    width: 100%;
    height: 100%;
    position: relative;
}

#canvas-wrapper {
    width: 50%;
    height: 100%;
    display: flex;
    justify-content: center;
    border: none;
}

#controls {
    display: flex;
    width: 75%;
    flex-direction: column;
}

#run {
    margin: 7px;
    width: 25%;
}

.ace_gutter-cell {
    color: #ddd;
}

.ace_comment {
    color: #e9db7b !important;
}

html, body {
    font-family: sans-serif;
    background-color: #3d3d3d;
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
}

body {
    display: flex;
    flex-direction: column;
}

#title {
    font-size: 24px;
    color: white;
    font-family: sans-serif;
    font-weight: 500;
}

#github-link {
    font-size: 16px;
    font-weight: 600;
    text-decoration: underline;
    padding-top: 0.2em;
    margin-left: 1rem;
    color: white;
}

#docs-link {
    font-size: 16px;
    font-weight: 600;
    text-decoration: underline;
    padding-top: 0.2em;
    margin-left: auto;
    color: white;
}

#title-area {
    display: flex;
    padding: 0.25em;
    margin-left: 0.5em;
    margin-right: 1.0em;
    justify-items: center;
}

#control-area {
    display: flex;
    padding: 0.25em;
    justify-items: center;
}

select {
    align-self: center;
    background-color: #6c757d;
    line-height: 1.5;
    text-align: center;
    vertical-align: middle;
    border: 1px solid transparent;
    padding: 0.375rem 0.75rem;
    font-size: 1rem;
    border-radius: 0.25rem;
    color: white;
}

select option:disabled {
    color: #ddd;
}

#warning {
    align-self: center;
    display: flex;
    color: #ccc;
    background-color: #2a2a2a;
    font-family: sans-serif;
    font-size: 0.8rem;
    width: 20rem;
    margin: 0;
    margin-left: 0.5rem;
    border-radius: 0.35rem;
    border: 1px solid black;
    padding: 0.25rem;
}

#warn-icon {
    font-size: 2.2rem;
    align-self: center;
    line-height: 0.9;
    margin-right: 0.3rem;
}

#compile-time-text {
    color: #ddd;
    align-self: end;
    margin-left: auto;
    margin-top: auto;
    font-size: 1.15rem;
    margin-right: 1rem;
}

</style>
  </head>
  <body>
    <div id='title-area'>
        <span id='title'>Graphv Playground</span>
        <a id='docs-link' target="about:blank" href='https://wlitwin.github.io/docs/graphv/graphv_webgl/Graphv_webgl/index.html'>Graphv Docs</a>
        <a id='github-link' target="about:blank" href='https://www.github.com/wlitwin/graphv'>Graphv GitHub</a>
    </div>
    <div id='control-area'>
    <button id='run' type='button' class='btn btn-secondary' onclick='runOcaml()'>Run</button>
    <select id='examples' onchange='loadExample()'>
        <option value="" disabled selected>Select an example</option>
        <option value="scaffold">Basic Scaffold</option>
        <option value="spinning_hello">Spinning Hello</option>
        <option value="render_texture">Render Texture</option>
        <option value="bouncing_rects">Bouncing Rectangles</option>
        <option value='preserve_drawing'>Preserve Drawing</option>
    </select>
    <div id='warning'><span id='warn-icon'>⚠</span><div>Firefox seems to have long load times ☹, looking into ways of improving that.</div></div>
    <div id='compile-time-text'></div>
    </div>
    <div id='top-div'>
        <div id='controls'>
            <div id='editor-wrapper'>
                <div id='editor'></div>
            </div>
        </div>
        <iframe sandbox="allow-scripts" id='canvas-wrapper' src='embed.html'></iframe>
    </div>

    <script defer type='text/javascript'>
        var editor = ace.edit('editor');
        var modified_code = false;
        editor.setOptions({
            fontSize: "14px",
            showPrintMargin: false,
        });
        editor.session.setMode('ace/mode/ocaml');
        editor.setTheme('ace/theme/ambiance');
        editor.getSession().on('change', function() {
            modified_code = true;
        });

        var compileTimeStart = 0;
        var compileTimeElement = document.getElementById('compile-time-text');
        var runButton = document.getElementById('run');

        function runOcaml() {
            runButton.disabled = true;
            var text = editor.getSession().getValue();
            var data = {
                'code': text
            };

            compileTimeStart = performance.now();
            document.getElementById('canvas-wrapper').contentWindow.postMessage(data, '*');
        }

        window.addEventListener('message', function(msg) {
            let totalTime = performance.now() - compileTimeStart;
            compileTimeElement.innerText = "Compile Time: " + (totalTime/1000).toFixed(2) + "s";
            runButton.disabled = false;
        });

        function loadExample() {
            let select = document.getElementById('examples');
            let script = document.getElementById(select.value);
            editor.getSession().setValue(script.innerHTML);
            modified_code = false;
        }

        window.onbeforeunload = function(event) {
            if (modified_code) {
                event.returnValue = null;
                return '';
            }
        }
    </script>
  </body>
  <script id='spinning_hello' type='text/ocaml'>open Js_of_ocaml
open Graphv_webgl

let webgl_ctx = create_webgl_ctx (object%js
    val stencil = true
end)

let _ =
    let vg = create
        ~flags:CreateFlags.(antialias lor stencil_strokes)
        webgl_ctx
    in

    (* File in this case is actually the CSS font name *)
    Text.create vg ~name:"sans" ~file:"arial" |> ignore;

    webgl_ctx##clearColor 0.3 0.3 0.32 1.;

    let rec render (time : float) =
        webgl_ctx##clear (
            webgl_ctx##._COLOR_BUFFER_BIT_
            lor webgl_ctx##._DEPTH_BUFFER_BIT_
            lor webgl_ctx##._STENCIL_BUFFER_BIT_
        );

        let device_ratio = Dom_html.window##.devicePixelRatio in
        begin_frame vg
            ~width:(float canvas##.width)
            ~height:(float canvas##.height)
            ~device_ratio
            ;
        Transform.scale vg ~x:device_ratio ~y:device_ratio;

        Path.begin_ vg;
        Path.rect vg ~x:40. ~y:40. ~w:421. ~h:421.;
        set_fill_color vg ~color:Color.(rgba ~r:154 ~g:203 ~b:255 ~a:200);
        fill vg;

        Transform.translate vg ~x:250. ~y:250.;
        Transform.rotate vg ~angle:(time *. 0.0005);

        Text.set_font_face vg ~name:"sans";
        Text.set_size vg ~size:48.;
        Text.set_align vg ~align:Align.(center lor middle);
        set_fill_color vg ~color:Color.white;
        Text.text vg ~x:0. ~y:0. "Hello World!";

        end_frame vg;

        Dom_html.window##requestAnimationFrame (Js.wrap_callback render)
        |> ignore;
    in

    Dom_html.window##requestAnimationFrame (Js.wrap_callback render)
    |> ignore;
;;
</script>
<script id='bouncing_rects' type='text/ocaml'>open Js_of_ocaml
module Gv = Graphv_webgl

type rect = {
    mutable x : float;
    mutable y : float;
    mutable w : float;
    mutable h : float;
    mutable vx : float;
    mutable vy : float;
}

let webgl_ctx = create_webgl_ctx (object%js
    val stencil = true
    (* try uncommenting this *)
    (* val preserveDrawingBuffer = true *)
end)

let _ =
    webgl_ctx##clearColor 0.3 0.3 0.32 1.;

    let vg = Gv.create
        ~flags:Gv.CreateFlags.(antialias lor stencil_strokes)
        webgl_ctx
    in

    Random.self_init();

    let vel = 400. in
    let vel_2 = ~-.(vel *. 0.5) in

    let rects = Array.init (1000) (fun _ ->
        {
            x = Random.float 200. +. 100.;
            y = Random.float 200. +. 100.;
            w = 20.;
            h = 20.;
            vx = Random.float vel +. vel_2;
            vy = Random.float vel +. vel_2;
        }
    ) in

    let time = ref 0. in
    let frames = ref 0 in
    let last_count = ref !time in
    let last_fps = ref "0" in

    Gv.Text.create vg ~name:"sans" ~file:"arial" |> ignore;

    let rec render (now : float) =
        let device_ratio = Dom_html.window##.devicePixelRatio in

        let attrs = webgl_ctx##getContextAttributes in
        if attrs##.preserveDrawingBuffer |> Js.to_bool then (
            webgl_ctx##clear (
                webgl_ctx##._DEPTH_BUFFER_BIT_
                lor webgl_ctx##._STENCIL_BUFFER_BIT_
            );
        ) else (
            webgl_ctx##clear (
                webgl_ctx##._COLOR_BUFFER_BIT_
                lor webgl_ctx##._DEPTH_BUFFER_BIT_
                lor webgl_ctx##._STENCIL_BUFFER_BIT_
            );
        );

        let now = now /. 1000. in
        let dt = now -. !time in
        time := now;

        if now -. !last_count >= 1. then (
            last_count := now;
            last_fps := Printf.sprintf "%d" !frames;
            frames := 0;
        );

        incr frames;

        let win_w = float canvas##.width in
        let win_h = float canvas##.height in

        Gv.begin_frame vg
            ~width:win_w
            ~height:win_h
            ~device_ratio
            ;

        let open Gv in

        let len = Array.length rects in
        for i=0 to len-1 do
            let r = rects.(i) in
            r.x <- r.x +. r.vx*.dt;
            r.y <- r.y +. r.vy*.dt;

            if r.x +. r.w > win_w then (
                r.x <- win_w -. r.w;
                r.vx <- ~-.(r.vx);
            );

            if r.y +. r.h > win_h then (
                r.y <- win_h -. r.h;
                r.vy <- ~-.(r.vy);
            );

            if r.x < 0. then (
                r.x <- 0.;
                r.vx <- ~-.(r.vx) +. Random.float 200. -. 100.;
            );

            if r.y < 0. then (
                r.y <- 0.;
                r.vy <- ~-.(r.vy) +. Random.float 200. -. 100.;
            );

            let r1 = Float.abs r.vx /. 400. *. 255. |> int_of_float in
            let g1 = Float.abs r.vy /. 400. *. 255. |> int_of_float in

            set_fill_color vg
                ~color:Gv.Color.(rgba ~r:r1 ~g:g1 ~b:255 ~a:255);

            Gv.Path.begin_ vg;
            Gv.Path.rect vg ~x:r.x ~y:r.y ~w:r.w ~h:r.h;
            Gv.fill vg;
        done;

        Text.set_size vg ~size:40.;
        Text.set_align vg ~align:Gv.Align.(left lor top);
        set_fill_color vg ~color:Color.black;
        Text.text vg ~x:2. ~y:2. !last_fps;
        set_fill_color vg ~color:Color.white;
        Text.text vg ~x:0. ~y:0. !last_fps;

        Gv.end_frame vg;

        Dom_html.window##requestAnimationFrame (Js.wrap_callback render)
        |> ignore;
    in

    render 0.
;;</script>
<script id='scaffold' type='text/ocaml'>open Js_of_ocaml
module Gv = Graphv_webgl

module FPS = struct
    type t = {
        mutable last : float;
        mutable last_fps : float;
        mutable fps : string;
        mutable fps_count : int; }
    let create () = { last = 0.; last_fps = 0.; fps = "0"; fps_count = 0; }
    let update t now =
        let now = now /. 1000. in
        let dt = now -. t.last in
        if now -. t.last_fps >= 1. then (
            t.fps <- Printf.sprintf "%d" t.fps_count;
            t.fps_count <- 0;
            t.last_fps <- now;
        );
        t.fps_count <- t.fps_count + 1;
        dt
    let draw t vg =
        let open Gv in
        Text.set_size vg ~size:40.;
        Text.set_align vg ~align:Gv.Align.(left lor top);
        set_fill_color vg ~color:Color.black;
        Text.text vg ~x:2. ~y:2. t.fps;
        set_fill_color vg ~color:Color.white;
        Text.text vg ~x:0. ~y:0. t.fps;
end

let webgl_ctx = create_webgl_ctx (object%js
    val stencil = true
end)

let _ =
    webgl_ctx##clearColor 0.3 0.3 0.32 1.;

    let vg = Gv.create
        ~flags:Gv.CreateFlags.(antialias lor stencil_strokes)
        webgl_ctx
    in

    Gv.Text.create vg ~name:"sans" ~file:"arial" |> ignore;

    let fps = FPS.create() in

    let rec render (now : float) =
        let device_ratio = Dom_html.window##.devicePixelRatio in
        webgl_ctx##clear (
            webgl_ctx##._COLOR_BUFFER_BIT_
            lor webgl_ctx##._DEPTH_BUFFER_BIT_
            lor webgl_ctx##._STENCIL_BUFFER_BIT_
        );

        (* Time since last frame in seconds *)
        let _dt = FPS.update fps now in

        Gv.begin_frame vg
            ~width:(float canvas##.width)
            ~height:(float canvas##.height)
            ~device_ratio
            ;

        (* Add code here *)

        FPS.draw fps vg;

        Gv.end_frame vg;

        Dom_html.window##requestAnimationFrame (Js.wrap_callback render)
        |> ignore;
    in

    render 0.
;;</script>
<script id='preserve_drawing' type='text/ocaml'>open Js_of_ocaml
module Gv = Graphv_webgl

let webgl_ctx = create_webgl_ctx (object%js
    val stencil = true
    val preserveDrawingBuffer = true
end)

type side =
    | Top
    | Bottom
    | Left
    | Right

type state =
    | Drawing of {
        mutable x : float;
        mutable y : float;
        mutable dx : bool;
        mutable dy : bool;
        mutable change : float;
        time : float;
    }
    | Clear of {
        mutable line : float;
    }
    | Border of {
        side : side;
        mutable value : float;
    }
;;

let performance_now () : float =
    Js.Unsafe.(meth_call (variable "performance")) "now" [||]
;;

let _ =
    webgl_ctx##clearColor 0.3 0.3 0.32 1.;

    let vg = Gv.create
        ~flags:Gv.CreateFlags.(antialias lor stencil_strokes)
        webgl_ctx
    in

    Random.self_init();

    let win_w = float canvas##.width in
    let win_h = float canvas##.height in

    let state = ref (Clear {line = win_h}) in

    webgl_ctx##clear (
        webgl_ctx##._COLOR_BUFFER_BIT_
    );

    let last = ref (performance_now()) in
    let rec render (now : float) =
        let device_ratio = Dom_html.window##.devicePixelRatio in
        webgl_ctx##clear (
            webgl_ctx##._DEPTH_BUFFER_BIT_
            lor webgl_ctx##._STENCIL_BUFFER_BIT_
        );

        let open Gv in

        webgl_ctx##enable webgl_ctx##._BLEND;
        webgl_ctx##blendFunc webgl_ctx##._ONE webgl_ctx##._ONE_MINUS_SRC_ALPHA_;

        let dt = (now -. !last) /. 1000. in
        last := now;

        Gv.begin_frame vg
            ~width:win_w
            ~height:win_h
            ~device_ratio
            ;

        let sz = 20. in
        let sz_i = int_of_float sz in

        let mx = Int.rem (int_of_float win_w) sz_i |> float in
        let my = Int.rem (int_of_float win_h) sz_i |> float in

        set_stroke_width vg ~width:2.;

        begin match !state with
        | Drawing box ->
            let r =
                let v = Random.int 100 in
                if v = 99 then (
                    sz*.0.5*.(Random.float 2. +. 2.)
                ) else if v > 30 then (
                    sz*.0.5
                ) else (
                    sz*.0.5*.(Random.float 1. +. 0.4)
                )
            in

            let cx = (box.x+.sz*.0.5) in
            let cy = (box.y+.sz*.0.5) in

            Path.begin_ vg;
            if Random.int 100 > 10 then (
                Path.circle vg ~cx ~cy ~r;
            ) else (
                Path.rect vg ~x:box.x ~y:box.y ~w:sz ~h:sz;
            );
            set_fill_color vg ~color:(Color.rgba ~r:255 ~g:255 ~b:255 ~a:64);
            fill vg;
            stroke vg;

            if box.change <= now then (
                if Random.bool() then (
                    box.dx <- not box.dx;
                ) else (
                    box.dy <- not box.dy;
                );
                box.change <- now +. Random.float 500. +. 250.;
            );

            box.x <- box.x +. (if box.dx then 1. else ~-.1.)*.sz;
            box.y <- box.y +. (if box.dy then 1. else ~-.1.)*.sz;

            if box.x < 0. then (
                box.x <- box.x +. sz;
                box.dx <- not box.dx;
            );

            if box.y < 0. then (
                box.y <- box.y +. sz;
                box.dy <- not box.dy;
            );

            if box.x +. sz >= win_w then (
                box.x <- box.x -. sz;
                box.dx <- not box.dx;
            );

             if box.y +. sz >= win_h then (
                box.y <- box.y -. sz;
                box.dy <- not box.dy;
            );

            if box.time <= now then (
                state := Clear {
                   line = win_h;
                };
            );

        | Clear clear ->
            clear.line <- clear.line -. (win_h)*.dt;

            Path.begin_ vg;
            Path.rect vg
                ~x:0.
                ~y:clear.line
                ~w:win_w
                ~h:(win_h -. clear.line);
            set_fill_color vg ~color:(Color.rgba ~r:255 ~g:128 ~b:64 ~a:255);
            fill vg;

            if clear.line <= 0. then (
                state := Border {
                    side = Bottom;
                    value = win_w;
                }
            )

        | Border ({side=Top; _} as border) ->
            border.value <- border.value +. (win_w*.4.)*.dt;
            Path.begin_ vg;
            Path.rect vg
                ~x:0.
                ~y:0.
                ~w:border.value
                ~h:(my*.0.5);
            set_fill_color vg ~color:Color.white;
            fill vg;

            if border.value >= win_w then (
                state := Border {
                    side = Right;
                    value = 0.;
                }
            )

        | Border ({side=Right; _} as border) ->
            border.value <- border.value +. (win_h*.4.)*.dt;
            Path.begin_ vg;
            Path.rect vg
                ~x:(win_w -. mx*.0.5)
                ~y:0.
                ~w:(mx*.0.5)
                ~h:border.value;
            set_fill_color vg ~color:Color.white;
            fill vg;

            if border.value >= win_h then (
                let x = Random.float (win_w *. 0.8) +. (win_w*.0.1) in
                let x =
                    let x = int_of_float x in
                    (x / sz_i * sz_i |> float) +. mx *. 0.5
                in

                let y = Random.float (win_h *. 0.8) +. (win_h*.0.1) in
                let y =
                    let y = int_of_float y in
                    (y / sz_i * sz_i |> float) +. my *. 0.5
                in

                state := Drawing {
                    x;
                    y;
                    dx = Random.bool();
                    dy = Random.bool();
                    change = Random.float 1000. +. 500.;
                    time = now +. 20000.;
                }
            )

        | Border ({side=Bottom; _} as border) ->
            border.value <- border.value -. (win_w*.4.)*.dt;
            Path.begin_ vg;
            Path.rect vg
                ~x:border.value
                ~y:(win_h -. my*.0.5)
                ~w:(win_w -. border.value)
                ~h:(my*.0.5);
            set_fill_color vg ~color:Color.white;
            fill vg;

            if border.value <= 0. then (
                state := Border {
                    side = Left;
                    value = win_h;
                }
            )

        | Border ({side=Left; _} as border) ->
            border.value <- border.value -. (win_h*.4.)*.dt;
            Path.begin_ vg;
            Path.rect vg
                ~x:0.
                ~y:border.value
                ~w:(mx*.0.5)
                ~h:(win_h -. border.value);
            set_fill_color vg ~color:Color.white;
            fill vg;

            if border.value <= 0. then (
                state := Border {
                    side = Top;
                    value = 0.;
                }
                
            )
        end;

        Gv.end_frame vg;

        Dom_html.window##requestAnimationFrame (Js.wrap_callback render)
        |> ignore;
    in

    render 0.
;;</script>
<script id='render_texture' type='text/ocaml'>open Js_of_ocaml
open Graphv_webgl

(*******************************************************************************

    WARNING - This program may take a bit longer to compile, it's pretty big!

********************************************************************************)

let gl = create_webgl_ctx (object%js
    val stencil = true
end)
;;

let texture =
    let tex = gl##createTexture in
    gl##bindTexture gl##._TEXTURE_2D_ tex;
    gl##texImage2D_new gl##._TEXTURE_2D_ 0
        gl##._RGBA 256 256
        0 gl##._RGBA gl##._UNSIGNED_BYTE_
        Js.null
    ;
    gl##texParameteri gl##._TEXTURE_2D_ gl##._TEXTURE_MIN_FILTER_ gl##._LINEAR;
    gl##texParameteri gl##._TEXTURE_2D_ gl##._TEXTURE_WRAP_S_ gl##._CLAMP_TO_EDGE_;
    gl##texParameteri gl##._TEXTURE_2D_ gl##._TEXTURE_WRAP_T_ gl##._CLAMP_TO_EDGE_;
    tex
;;

let fb =
    let fb = gl##createFramebuffer in
    gl##bindFramebuffer gl##._FRAMEBUFFER fb;
    gl##framebufferTexture2D gl##._FRAMEBUFFER
        gl##._COLOR_ATTACHMENT0_
        gl##._TEXTURE_2D_
        texture 0;
    fb
;;

let cubePosBuf =
    let data =
    new%js Typed_array.float32Array_fromArray (Js.array [|
        -0.5; -0.5;  -0.5;
        -0.5;  0.5;  -0.5;
         0.5; -0.5;  -0.5;
        -0.5;  0.5;  -0.5;
         0.5;  0.5;  -0.5;
         0.5; -0.5;  -0.5;

        -0.5; -0.5;   0.5;
         0.5; -0.5;   0.5;
        -0.5;  0.5;   0.5;
        -0.5;  0.5;   0.5;
         0.5; -0.5;   0.5;
         0.5;  0.5;   0.5;

        -0.5;   0.5; -0.5;
        -0.5;   0.5;  0.5;
         0.5;   0.5; -0.5;
        -0.5;   0.5;  0.5;
         0.5;   0.5;  0.5;
         0.5;   0.5; -0.5;

        -0.5;  -0.5; -0.5;
         0.5;  -0.5; -0.5;
        -0.5;  -0.5;  0.5;
        -0.5;  -0.5;  0.5;
         0.5;  -0.5; -0.5;
         0.5;  -0.5;  0.5;

        -0.5;  -0.5; -0.5;
        -0.5;  -0.5;  0.5;
        -0.5;   0.5; -0.5;
        -0.5;  -0.5;  0.5;
        -0.5;   0.5;  0.5;
        -0.5;   0.5; -0.5;

         0.5;  -0.5; -0.5;
         0.5;   0.5; -0.5;
         0.5;  -0.5;  0.5;
         0.5;  -0.5;  0.5;
         0.5;   0.5; -0.5;
         0.5;   0.5;  0.5;
    |]) in
    let buf = gl##createBuffer in
    gl##bindBuffer gl##._ARRAY_BUFFER_ buf;
    gl##bufferData gl##._ARRAY_BUFFER_ data gl##._STATIC_DRAW_;
    buf
;;

let cubeTexBuf =
    let data =
    new%js Typed_array.float32Array_fromArray (Js.array [|
        0.; 0.;
        0.; 1.;
        1.; 0.;
        0.; 1.;
        1.; 1.;
        1.; 0.;

        0.; 0.;
        0.; 1.;
        1.; 0.;
        1.; 0.;
        0.; 1.;
        1.; 1.;

        0.; 0.;
        0.; 1.;
        1.; 0.;
        0.; 1.;
        1.; 1.;
        1.; 0.;

        0.; 0.;
        0.; 1.;
        1.; 0.;
        1.; 0.;
        0.; 1.;
        1.; 1.;

        0.; 0.;
        0.; 1.;
        1.; 0.;
        0.; 1.;
        1.; 1.;
        1.; 0.;

        0.; 0.;
        0.; 1.;
        1.; 0.;
        1.; 0.;
        0.; 1.;
        1.; 1.;
    |]) in
    let buf = gl##createBuffer in
    gl##bindBuffer gl##._ARRAY_BUFFER_ buf;
    gl##bufferData gl##._ARRAY_BUFFER_ data gl##._STATIC_DRAW_;
    buf
;;

let vertex_src = {|
  attribute vec3 pos;
  attribute vec2 tex;

  uniform mat4 proj;
  uniform mat4 view;
  uniform float time;

  varying vec2 texcoord;

  mat4 rotationMatrix(vec3 axis, float angle)
  {
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;

    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
  }

  void main() {
      mat4 rot = rotationMatrix(vec3(0, 1, 0), time);
      gl_Position = proj * view * rot * vec4(pos, 1);
      texcoord = tex;
  }
|};;

let fragment_src = {|
  precision highp float;
  varying vec2 texcoord;
  uniform sampler2D texture;
  void main() {
      gl_FragColor = texture2D(texture, vec2(1.0 - texcoord.x, texcoord.y));
  }
|};;

let perspective fov aspect near far =
    let d2r = Float.pi /. 180. in
    let y_scale = 1. /. Float.(tan (d2r*.fov /. 2.)) in
    let x_scale = y_scale /. aspect in
    let near_far = near -. far in
    new%js Typed_array.float32Array_fromArray (Js.array [|
        x_scale; 0.; 0.; 0.;
        0.; y_scale; 0.; 0.;
        0.; 0.; (far +. near) /. near_far; ~-.1.;
        0.; 0.; 2.*.far*.near /. near_far; 0.;
    |])
;;

module V3 = struct
    type t = {x:float; y:float; z:float}
    let mk x y z = {x;y;z};;
    let len v = Float.sqrt (v.x*.v.x +. v.y*.v.y +. v.z*.v.z);;
    let norm v =
        let l = len v in
        { x = v.x/.l; y = v.y/.l; z = v.z/.l };;
    let sub v1 v2 = {x=v1.x-.v2.x; y=v1.y-.v2.y; z=v1.z-.v2.z};;
    let cross v1 v2 = {
        x=v1.y*.v2.z -. v1.z*.v2.y;
        y=v1.z*.v2.x -. v1.x*.v2.z;
        z=v1.x*.v2.y -. v1.y*.v2.x;
    };;
    let dot v1 v2 = v1.x*.v2.x +. v1.y*.v2.y +. v1.z*.v2.z;;
end;;

let look_at eye target up =
  let open V3 in
  let f = norm (sub target eye) in
  let u = norm up in
  let s = norm (cross f u) in
  let u = cross s f in
  new%js Typed_array.float32Array_fromArray (Js.array [|
    s.x; u.x; ~-.(f.x); 0.;
    s.y; u.y; ~-.(f.y); 0.;
    s.z; u.z; ~-.(f.z); 0.;
    ~-.(dot s eye); ~-.(dot u eye); (dot f eye); 1.;
  |])
;;

let cube_prog, cubePos, cubeTex, texLoc, projLoc, viewLoc, timeLoc =
    let vertex = gl##createShader gl##._VERTEX_SHADER_ in
    let frag = gl##createShader gl##._FRAGMENT_SHADER_ in

    gl##shaderSource vertex (Js.string vertex_src);
    gl##shaderSource frag (Js.string fragment_src);

    gl##compileShader vertex;
    gl##compileShader frag;

    if not (gl##getShaderParameter vertex gl##._COMPILE_STATUS_ |> Js.to_bool) then (
        print_endline "Failed to compile vertex program";
        let info = gl##getShaderInfoLog vertex in
        print_endline Js.(to_string info);
    );


    if not (gl##getShaderParameter frag gl##._COMPILE_STATUS_ |> Js.to_bool) then (
        print_endline "Failed to compile fragment program";
        let info = gl##getShaderInfoLog frag in
        print_endline Js.(to_string info);
    );

    let prog = gl##createProgram in
    gl##attachShader prog vertex;
    gl##attachShader prog frag;
    gl##linkProgram prog;

    if not (gl##getProgramParameter prog gl##._LINK_STATUS_ |> Js.to_bool) then (
        print_endline "Failed to link program"
    );

    let cube_pos = gl##getAttribLocation prog (Js.string "pos") in
    let cube_tex = gl##getAttribLocation prog (Js.string "tex") in

    let tex_loc = gl##getUniformLocation prog (Js.string "texture") in
    let proj_loc = gl##getUniformLocation prog (Js.string "proj") in
    let view_loc = gl##getUniformLocation prog (Js.string "view") in
    let time_loc = gl##getUniformLocation prog (Js.string "time") in

    prog, cube_pos, cube_tex, tex_loc, proj_loc, view_loc, time_loc
;;

let draw_cube aspect proj view time =
    gl##useProgram cube_prog;

    gl##enableVertexAttribArray cubePos;
    gl##bindBuffer gl##._ARRAY_BUFFER_ cubePosBuf;
    gl##vertexAttribPointer cubePos 3 gl##._FLOAT Js._false 0 0;
    gl##enableVertexAttribArray cubeTex;
    gl##bindBuffer gl##._ARRAY_BUFFER_ cubeTexBuf;
    gl##vertexAttribPointer cubeTex 2 gl##._FLOAT Js._false 0 0;

    gl##uniform1i texLoc 0;
    gl##uniformMatrix4fv_typed projLoc Js._false proj;
    gl##uniformMatrix4fv_typed viewLoc Js._false view;
    gl##uniform1f timeLoc time;

    gl##drawArrays gl##._TRIANGLES 0 36;
;;

let rec render_hello vg (time : float) =
    gl##bindFramebuffer gl##._FRAMEBUFFER fb;
    gl##bindTexture_ gl##._TEXTURE_2D_ Js.null;

    gl##viewport 0 0 256 256;
    gl##clearColor 0.3 0.3 0.32 1.;

    gl##clear (
        gl##._COLOR_BUFFER_BIT_
        lor gl##._DEPTH_BUFFER_BIT_
        lor gl##._STENCIL_BUFFER_BIT_
    );

    begin_frame vg
        ~width:256.
        ~height:256.
        ~device_ratio:1.
        ;

    Path.begin_ vg;
    Path.rect vg ~x:16. ~y:16. ~w:(256. -. 32.) ~h:(256. -. 32.);
    set_fill_color vg ~color:Color.(rgba ~r:154 ~g:203 ~b:255 ~a:200);
    fill vg;

    Transform.translate vg ~x:128. ~y:128.;
    Transform.rotate vg ~angle:(time *. 0.002);

    Text.set_font_face vg ~name:"sans";
    Text.set_size vg ~size:32.;
    Text.set_align vg ~align:Align.(center lor middle);
    set_fill_color vg ~color:Color.white;
    Text.text vg ~x:0. ~y:0. "Hello World!";

    end_frame vg
;;

let _ =
    let vg = create
        ~flags:CreateFlags.(antialias lor stencil_strokes)
        gl
    in

    (* File in this case is actually the CSS font name *)
    Text.create vg ~name:"sans" ~file:"arial" |> ignore;

    let win_w = canvas##.width in
    let win_h = canvas##.height in

    let f_w = float win_w in
    let f_h = float win_h in


    let aspect = f_w /. f_h in
    let proj = perspective 60. aspect 0.1 100. in
    let view = look_at V3.(mk 0. 0.8 2.) V3.(mk 0. 0. 0.) V3.(mk 0. 1. 0.) in

    let rec render now =
        render_hello vg now;

        gl##bindFramebuffer_ gl##._FRAMEBUFFER Js.null;
        gl##bindTexture gl##._TEXTURE_2D_ texture;
        gl##viewport 0 0 win_w win_h;

        gl##clearColor 0.1 0.1 0.105 1.;
        gl##clear (
            gl##._COLOR_BUFFER_BIT_
            lor gl##._DEPTH_BUFFER_BIT_
            lor gl##._STENCIL_BUFFER_BIT_
        );

        gl##enable gl##._DEPTH_TEST_;

        draw_cube aspect proj view (now /. 1000. *. 0.25);

        Dom_html.window##requestAnimationFrame (Js.wrap_callback render)
        |> ignore;
    in

    render 0.
;;</script>
</html>
