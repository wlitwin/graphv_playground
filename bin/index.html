<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
          "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Graphv Playground</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.13/ace.min.js" integrity="sha512-jB1NOQkR0yLnWmEZQTUW4REqirbskxoYNltZE+8KzXqs9gHG5mrxLR5w3TwUn6AylXkhZZWTPP894xcX/X8Kbg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.13/mode-ocaml.min.js" integrity="sha512-eNLvVhsqupKHLPWDlslUqBr0HTbb8KFm/azDm7ukE2PGSlmfPUsNuOTh8z+u8QjrsDpIQog09ntWF1Mo1a4aHA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.13/theme-ambiance.min.js" integrity="sha512-JSlcMPGsnCu53ixgQjR6qgTQNy/IzjibQob3GSP2JfZtd3naC3H6+NrOs1nDG8rsLulHYCIfBaXaU07G1PbR1g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.1.1/js/bootstrap.min.js" integrity="sha512-ewfXo9Gq53e1q1+WDTjaHAGZ8UvCWq0eXONhwDuIoaH8xz2r96uoAYaQCm1oQhnBfRXrvJztNXFsTloJfgbL5Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.1.1/css/bootstrap.min.css" integrity="sha512-6KY5s6UI5J7SVYuZB4S/CZMyPylqyyNZco376NM2Z8Sb8OxEdp02e1jkKk/wZxIEmjQ6DRCEBhni+gpr9c4tvA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.13/keybinding-vim.min.js" integrity="sha512-xp5tDiJMTiTOG6fjhMjNGaV3zw+kyaHq53hWvc5XrMvj/Pe/EOaby08LVHJp50xCE4VFF9rnJpRP4+JJyelGvQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.13/keybinding-emacs.min.js" integrity="sha512-1Z4E+xA+twF7jPCjJSFpeywof+mG40O66/pLMnAElym2Bu34nUTtTRQZG/eDkGIrp+bORyr2Ej2BWd6/sJBMWA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<style>

#top-div {
    display: flex;
    flex-direction: row;
    height: 100%;
}

#editor-wrapper {
    width: 100%;
    height: 100%;
    background-color: #3d3d3d;
}

#editor {
    width: 100%;
    height: 100%;
    position: relative;
}

#canvas-wrapper {
    width: 50%;
    height: 100%;
    display: flex;
    justify-content: center;
    border: none;
}

#controls {
    display: flex;
    width: 75%;
    flex-direction: column;
}

#run {
    margin: 7px;
    width: 25%;
}

.ace_gutter-cell {
    color: #ddd;
}

.ace_comment {
    color: #e9db7b !important;
}

html, body {
    font-family: sans-serif;
    background-color: #3d3d3d;
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
}

body {
    display: flex;
    flex-direction: column;
}

#title {
    font-size: 24px;
    color: white;
    font-family: sans-serif;
    font-weight: 500;
}

#github-link {
    font-size: 16px;
    font-weight: 600;
    text-decoration: underline;
    padding-top: 0.2em;
    margin-left: 1rem;
    color: white;
}

#docs-link {
    font-size: 16px;
    font-weight: 600;
    text-decoration: underline;
    padding-top: 0.2em;
    margin-left: auto;
    color: white;
}

#title-area {
    display: flex;
    padding: 0.25em;
    margin-left: 0.5em;
    margin-right: 1.0em;
    justify-items: center;
}

#control-area {
    display: flex;
    padding: 0.25em;
    justify-items: center;
}

select {
    align-self: center;
    background-color: #6c757d;
    line-height: 1.5;
    text-align: center;
    vertical-align: middle;
    border: 1px solid transparent;
    padding: 0.375rem 0.75rem;
    font-size: 1rem;
    border-radius: 0.25rem;
    color: white;
}

select option:disabled {
    color: #ddd;
}

#warning {
    align-self: center;
    display: flex;
    color: #ccc;
    background-color: #2a2a2a;
    font-family: sans-serif;
    font-size: 0.8rem;
    width: 20rem;
    margin: 0;
    margin-left: 0.5rem;
    border-radius: 0.35rem;
    border: 1px solid black;
    padding: 0.25rem;
}

#warn-icon {
    font-size: 2.2rem;
    align-self: center;
    line-height: 0.9;
    margin-right: 0.3rem;
}

#compile-time-text {
    color: #ddd;
    align-self: end;
    margin-left: auto;
    margin-top: auto;
    font-size: 1.15rem;
    margin-right: 1rem;
}

</style>
  </head>
  <body>
    <div id='title-area'>
        <span id='title'>Graphv Playground</span>
        <a id='docs-link' target="about:blank" href='https://wlitwin.github.io/docs/graphv/graphv_webgl/Graphv_webgl/index.html'>Graphv Docs</a>
        <a id='github-link' target="about:blank" href='https://www.github.com/wlitwin/graphv'>Graphv GitHub</a>
    </div>
    <div id='control-area'>
    <button id='run' type='button' class='btn btn-secondary' onclick='runOcaml()'>Run</button>
    <select id='examples' onchange='loadExample()'>
        <option value="" disabled selected>Select an example</option>
        <option value="scaffold">Basic Scaffold</option>
        <option value="spinning_hello">Spinning Hello</option>
        <option value="bouncing_rects">Bouncing Rectangles</option>
        <option value='preserve_drawing'>Preserve Drawing</option>
    </select>
    <div id='warning'><span id='warn-icon'>⚠</span><div>Firefox seems to have long load times ☹, looking into ways of improving that.</div></div>
    <div id='compile-time-text'></div>
    </div>
    <div id='top-div'>
        <div id='controls'>
            <div id='editor-wrapper'>
                <div id='editor'></div>
            </div>
        </div>
        <iframe sandbox="allow-scripts" id='canvas-wrapper' src='embed.html'></iframe>
    </div>

    <script defer type='text/javascript'>
        var editor = ace.edit('editor');
        var modified_code = false;
        editor.setOptions({
            fontSize: "14px",
            showPrintMargin: false,
        });
        editor.session.setMode('ace/mode/ocaml');
        editor.setTheme('ace/theme/ambiance');
        editor.getSession().on('change', function() {
            modified_code = true;
        });

        var compileTimeStart = 0;
        var compileTimeElement = document.getElementById('compile-time-text');
        var runButton = document.getElementById('run');

        function runOcaml() {
            runButton.disabled = true;
            var text = editor.getSession().getValue();
            var data = {
                'code': text
            };

            compileTimeStart = performance.now();
            document.getElementById('canvas-wrapper').contentWindow.postMessage(data, '*');
        }

        window.addEventListener('message', function(msg) {
            let totalTime = performance.now() - compileTimeStart;
            compileTimeElement.innerText = "Compile Time: " + (totalTime/1000).toFixed(2) + "s";
            runButton.disabled = false;
        });

        function loadExample() {
            let select = document.getElementById('examples');
            let script = document.getElementById(select.value);
            editor.getSession().setValue(script.innerHTML);
            modified_code = false;
        }

        window.onbeforeunload = function(event) {
            if (modified_code) {
                event.returnValue = null;
                return '';
            }
        }
    </script>
  </body>
  <script id='spinning_hello' type='text/ocaml'>open Js_of_ocaml
open Graphv_webgl

let webgl_ctx = create_webgl_ctx (object%js
    val stencil = true
end)

let _ =
    let vg = create
        ~flags:CreateFlags.(antialias lor stencil_strokes)
        webgl_ctx
    in

    (* File in this case is actually the CSS font name *)
    Text.create vg ~name:"sans" ~file:"arial" |> ignore;

    webgl_ctx##clearColor 0.3 0.3 0.32 1.;

    let rec render (time : float) =
        webgl_ctx##clear (
            webgl_ctx##._COLOR_BUFFER_BIT_
            lor webgl_ctx##._DEPTH_BUFFER_BIT_
            lor webgl_ctx##._STENCIL_BUFFER_BIT_
        );

        let device_ratio = Dom_html.window##.devicePixelRatio in
        begin_frame vg
            ~width:(float canvas##.width)
            ~height:(float canvas##.height)
            ~device_ratio
            ;
        Transform.scale vg ~x:device_ratio ~y:device_ratio;

        Path.begin_ vg;
        Path.rect vg ~x:40. ~y:40. ~w:421. ~h:421.;
        set_fill_color vg ~color:Color.(rgba ~r:154 ~g:203 ~b:255 ~a:200);
        fill vg;

        Transform.translate vg ~x:250. ~y:250.;
        Transform.rotate vg ~angle:(time *. 0.0005);

        Text.set_font_face vg ~name:"sans";
        Text.set_size vg ~size:48.;
        Text.set_align vg ~align:Align.(center lor middle);
        set_fill_color vg ~color:Color.white;
        Text.text vg ~x:0. ~y:0. "Hello World!";

        end_frame vg;

        Dom_html.window##requestAnimationFrame (Js.wrap_callback render)
        |> ignore;
    in

    Dom_html.window##requestAnimationFrame (Js.wrap_callback render)
    |> ignore;
;;
</script>
<script id='bouncing_rects' type='text/ocaml'>open Js_of_ocaml
module Gv = Graphv_webgl

type rect = {
    mutable x : float;
    mutable y : float;
    mutable w : float;
    mutable h : float;
    mutable vx : float;
    mutable vy : float;
}

let webgl_ctx = create_webgl_ctx (object%js
    val stencil = true
    (* try uncommenting this *)
    (* val preserveDrawingBuffer = true *)
end)

let _ =
    webgl_ctx##clearColor 0.3 0.3 0.32 1.;

    let vg = Gv.create
        ~flags:Gv.CreateFlags.(antialias lor stencil_strokes)
        webgl_ctx
    in

    Random.self_init();

    let vel = 400. in
    let vel_2 = ~-.(vel *. 0.5) in

    let rects = Array.init (1000) (fun _ ->
        {
            x = Random.float 200. +. 100.;
            y = Random.float 200. +. 100.;
            w = 20.;
            h = 20.;
            vx = Random.float vel +. vel_2;
            vy = Random.float vel +. vel_2;
        }
    ) in

    let time = ref 0. in
    let frames = ref 0 in
    let last_count = ref !time in
    let last_fps = ref "0" in

    Gv.Text.create vg ~name:"sans" ~file:"arial" |> ignore;

    let rec render (now : float) =
        let device_ratio = Dom_html.window##.devicePixelRatio in

        let attrs = webgl_ctx##getContextAttributes in
        if attrs##.preserveDrawingBuffer |> Js.to_bool then (
            webgl_ctx##clear (
                webgl_ctx##._DEPTH_BUFFER_BIT_
                lor webgl_ctx##._STENCIL_BUFFER_BIT_
            );
        ) else (
            webgl_ctx##clear (
                webgl_ctx##._COLOR_BUFFER_BIT_
                lor webgl_ctx##._DEPTH_BUFFER_BIT_
                lor webgl_ctx##._STENCIL_BUFFER_BIT_
            );
        );

        let now = now /. 1000. in
        let dt = now -. !time in
        time := now;

        if now -. !last_count >= 1. then (
            last_count := now;
            last_fps := Printf.sprintf "%d" !frames;
            frames := 0;
        );

        incr frames;

        let win_w = float canvas##.width in
        let win_h = float canvas##.height in

        Gv.begin_frame vg
            ~width:win_w
            ~height:win_h
            ~device_ratio
            ;

        let open Gv in

        let len = Array.length rects in
        for i=0 to len-1 do
            let r = rects.(i) in
            r.x <- r.x +. r.vx*.dt;
            r.y <- r.y +. r.vy*.dt;

            if r.x +. r.w > win_w then (
                r.x <- win_w -. r.w;
                r.vx <- ~-.(r.vx);
            );

            if r.y +. r.h > win_h then (
                r.y <- win_h -. r.h;
                r.vy <- ~-.(r.vy);
            );

            if r.x < 0. then (
                r.x <- 0.;
                r.vx <- ~-.(r.vx) +. Random.float 200. -. 100.;
            );

            if r.y < 0. then (
                r.y <- 0.;
                r.vy <- ~-.(r.vy) +. Random.float 200. -. 100.;
            );

            let r1 = Float.abs r.vx /. 400. *. 255. |> int_of_float in
            let g1 = Float.abs r.vy /. 400. *. 255. |> int_of_float in

            set_fill_color vg
                ~color:Gv.Color.(rgba ~r:r1 ~g:g1 ~b:255 ~a:255);

            Gv.Path.begin_ vg;
            Gv.Path.rect vg ~x:r.x ~y:r.y ~w:r.w ~h:r.h;
            Gv.fill vg;
        done;

        Text.set_size vg ~size:40.;
        Text.set_align vg ~align:Gv.Align.(left lor top);
        set_fill_color vg ~color:Color.black;
        Text.text vg ~x:2. ~y:2. !last_fps;
        set_fill_color vg ~color:Color.white;
        Text.text vg ~x:0. ~y:0. !last_fps;

        Gv.end_frame vg;

        Dom_html.window##requestAnimationFrame (Js.wrap_callback render)
        |> ignore;
    in

    render 0.
;;</script>
<script id='scaffold' type='text/ocaml'>open Js_of_ocaml
module Gv = Graphv_webgl

module FPS = struct
    type t = {
        mutable last : float;
        mutable last_fps : float;
        mutable fps : string;
        mutable fps_count : int; }
    let create () = { last = 0.; last_fps = 0.; fps = "0"; fps_count = 0; }
    let update t now =
        let now = now /. 1000. in
        let dt = now -. t.last in
        if now -. t.last_fps >= 1. then (
            t.fps <- Printf.sprintf "%d" t.fps_count;
            t.fps_count <- 0;
            t.last_fps <- now;
        );
        t.fps_count <- t.fps_count + 1;
        dt
    let draw t vg =
        let open Gv in
        Text.set_size vg ~size:40.;
        Text.set_align vg ~align:Gv.Align.(left lor top);
        set_fill_color vg ~color:Color.black;
        Text.text vg ~x:2. ~y:2. t.fps;
        set_fill_color vg ~color:Color.white;
        Text.text vg ~x:0. ~y:0. t.fps;
end

let webgl_ctx = create_webgl_ctx (object%js
    val stencil = true
end)

let _ =
    webgl_ctx##clearColor 0.3 0.3 0.32 1.;

    let vg = Gv.create
        ~flags:Gv.CreateFlags.(antialias lor stencil_strokes)
        webgl_ctx
    in

    Gv.Text.create vg ~name:"sans" ~file:"arial" |> ignore;

    let fps = FPS.create() in

    let rec render (now : float) =
        let device_ratio = Dom_html.window##.devicePixelRatio in
        webgl_ctx##clear (
            webgl_ctx##._COLOR_BUFFER_BIT_
            lor webgl_ctx##._DEPTH_BUFFER_BIT_
            lor webgl_ctx##._STENCIL_BUFFER_BIT_
        );

        (* Time since last frame in seconds *)
        let _dt = FPS.update fps now in

        Gv.begin_frame vg
            ~width:(float canvas##.width)
            ~height:(float canvas##.height)
            ~device_ratio
            ;

        (* Add code here *)

        FPS.draw fps vg;

        Gv.end_frame vg;

        Dom_html.window##requestAnimationFrame (Js.wrap_callback render)
        |> ignore;
    in

    render 0.
;;</script>
<script id='preserve_drawing' type='text/ocaml'>open Js_of_ocaml
module Gv = Graphv_webgl

let webgl_ctx = create_webgl_ctx (object%js
    val stencil = true
    val preserveDrawingBuffer = true
end)

type side =
    | Top
    | Bottom
    | Left
    | Right

type state =
    | Drawing of {
        mutable x : float;
        mutable y : float;
        mutable dx : bool;
        mutable dy : bool;
        mutable change : float;
        time : float;
    }
    | Clear of {
        mutable line : float;
    }
    | Border of {
        side : side;
        mutable value : float;
    }
;;

let performance_now () : float =
    Js.Unsafe.(meth_call (variable "performance")) "now" [||]
;;

let _ =
    webgl_ctx##clearColor 0.3 0.3 0.32 1.;

    let vg = Gv.create
        ~flags:Gv.CreateFlags.(antialias lor stencil_strokes)
        webgl_ctx
    in

    Random.self_init();

    let win_w = float canvas##.width in
    let win_h = float canvas##.height in

    let state = ref (Clear {line = win_h}) in

    webgl_ctx##clear (
        webgl_ctx##._COLOR_BUFFER_BIT_
    );

    let last = ref (performance_now()) in
    let rec render (now : float) =
        let device_ratio = Dom_html.window##.devicePixelRatio in
        webgl_ctx##clear (
            webgl_ctx##._DEPTH_BUFFER_BIT_
            lor webgl_ctx##._STENCIL_BUFFER_BIT_
        );

        let open Gv in

        webgl_ctx##enable webgl_ctx##._BLEND;
        webgl_ctx##blendFunc webgl_ctx##._ONE webgl_ctx##._ONE_MINUS_SRC_ALPHA_;

        let dt = (now -. !last) /. 1000. in
        last := now;

        Gv.begin_frame vg
            ~width:win_w
            ~height:win_h
            ~device_ratio
            ;

        let sz = 20. in
        let sz_i = int_of_float sz in

        let mx = Int.rem (int_of_float win_w) sz_i |> float in
        let my = Int.rem (int_of_float win_h) sz_i |> float in

        set_stroke_width vg ~width:2.;

        begin match !state with
        | Drawing box ->
            let r =
                let v = Random.int 100 in
                if v = 99 then (
                    sz*.0.5*.(Random.float 2. +. 2.)
                ) else if v > 30 then (
                    sz*.0.5
                ) else (
                    sz*.0.5*.(Random.float 1. +. 0.4)
                )
            in

            let cx = (box.x+.sz*.0.5) in
            let cy = (box.y+.sz*.0.5) in

            Path.begin_ vg;
            if Random.int 100 > 10 then (
                Path.circle vg ~cx ~cy ~r;
            ) else (
                Path.rect vg ~x:box.x ~y:box.y ~w:sz ~h:sz;
            );
            set_fill_color vg ~color:(Color.rgba ~r:255 ~g:255 ~b:255 ~a:64);
            fill vg;
            stroke vg;

            if box.change <= now then (
                if Random.bool() then (
                    box.dx <- not box.dx;
                ) else (
                    box.dy <- not box.dy;
                );
                box.change <- now +. Random.float 500. +. 250.;
            );

            box.x <- box.x +. (if box.dx then 1. else ~-.1.)*.sz;
            box.y <- box.y +. (if box.dy then 1. else ~-.1.)*.sz;

            if box.x < 0. then (
                box.x <- box.x +. sz;
                box.dx <- not box.dx;
            );

            if box.y < 0. then (
                box.y <- box.y +. sz;
                box.dy <- not box.dy;
            );

            if box.x +. sz >= win_w then (
                box.x <- box.x -. sz;
                box.dx <- not box.dx;
            );

             if box.y +. sz >= win_h then (
                box.y <- box.y -. sz;
                box.dy <- not box.dy;
            );

            if box.time <= now then (
                state := Clear {
                   line = win_h;
                };
            );

        | Clear clear ->
            clear.line <- clear.line -. (win_h)*.dt;

            Path.begin_ vg;
            Path.rect vg
                ~x:0.
                ~y:clear.line
                ~w:win_w
                ~h:(win_h -. clear.line);
            set_fill_color vg ~color:(Color.rgba ~r:255 ~g:128 ~b:64 ~a:255);
            fill vg;

            if clear.line <= 0. then (
                state := Border {
                    side = Top;
                    value = 0.;
                }
            )

        | Border ({side=Top; _} as border) ->
            border.value <- border.value +. (win_w*.4.)*.dt;
            Path.begin_ vg;
            Path.rect vg
                ~x:0.
                ~y:0.
                ~w:border.value
                ~h:(my*.0.5);
            set_fill_color vg ~color:Color.white;
            fill vg;

            if border.value >= win_w then (
                state := Border {
                    side = Right;
                    value = 0.;
                }
            )

        | Border ({side=Right; _} as border) ->
            border.value <- border.value +. (win_h*.4.)*.dt;
            Path.begin_ vg;
            Path.rect vg
                ~x:(win_w -. mx*.0.5)
                ~y:0.
                ~w:(mx*.0.5)
                ~h:border.value;
            set_fill_color vg ~color:Color.white;
            fill vg;

            if border.value >= win_h then (
                state := Border {
                    side = Bottom;
                    value = win_w;
                }
            )

        | Border ({side=Bottom; _} as border) ->
            border.value <- border.value -. (win_w*.4.)*.dt;
            Path.begin_ vg;
            Path.rect vg
                ~x:border.value
                ~y:(win_h -. my*.0.5)
                ~w:(win_w -. border.value)
                ~h:(my*.0.5);
            set_fill_color vg ~color:Color.white;
            fill vg;

            if border.value <= 0. then (
                state := Border {
                    side = Left;
                    value = win_h;
                }
            )

        | Border ({side=Left; _} as border) ->
            border.value <- border.value -. (win_h*.4.)*.dt;
            Path.begin_ vg;
            Path.rect vg
                ~x:0.
                ~y:border.value
                ~w:(mx*.0.5)
                ~h:(win_h -. border.value);
            set_fill_color vg ~color:Color.white;
            fill vg;

            if border.value <= 0. then (
                let x = Random.float (win_w *. 0.8) +. (win_w*.0.1) in
                let x =
                    let x = int_of_float x in
                    (x / sz_i * sz_i |> float) +. mx *. 0.5
                in

                let y = Random.float (win_h *. 0.8) +. (win_h*.0.1) in
                let y =
                    let y = int_of_float y in
                    (y / sz_i * sz_i |> float) +. my *. 0.5
                in

                state := Drawing {
                    x;
                    y;
                    dx = Random.bool();
                    dy = Random.bool();
                    change = Random.float 1000. +. 500.;
                    time = now +. 20000.;
                }
            )
        end;

        Gv.end_frame vg;

        Dom_html.window##requestAnimationFrame (Js.wrap_callback render)
        |> ignore;
    in

    render 0.
;;</script>
</html>
